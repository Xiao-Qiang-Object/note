#!/bin/bash

# Time : 2018/11/14 9:54
# Author : 
# File : ${NAME}.sh
# Describe: 
#
# Change:
#

#打印日志
print_log()
{
current_time=$(date "+%Y-%m-%d %H:%M:%S")
echo "$current_time $@"
}

startsec=$(date +%s)

source /data/etlscript/PUBLIC/SCRIPT/TOOL/scriptHelper.sh
resoveJson $1
checkLogPath $task_name
exec &> $CMRH_DATAHUB_SCRIPT_LOG/$EXE_DATE/$task_name/$run_serial_no.log

#代码段 1 开始

#以下代码为beeline模板,用不到可删掉
job_path=$0

#脚本所在文件夹路径
sh_directory=`echo ${job_path%/*}`
#脚本名称
job_name=`echo ${job_path##*/}`
job_name=`echo ${job_name%.*}`
hivejdbc="jdbc:hive2://${src_ip}:${src_port}"

print_log "job_path:$job_path"
print_log "sh_directory:$sh_directory"
print_log "job_name:$job_name"
print_log "hivejdbc:$hivejdbc"

print_log "并发执行开始" 
#自定义并发数
thead_num=5
#以进程ID号命名管道文件
tmp_fifo_file="/tmp/$$.fifo"
#创建临时管道文件
mkfifo $tmp_fifo_file
#以读写方式打开tmp_fifo_file管道文件,文件描述符为4，也可以取3-9任意描述符
exec 4<>$tmp_fifo_file
for ((i=0;i<$thead_num;i++)) #利用for循环向管道中输入并发数量的空行
do
echo ""
done >&4 #输出重导向到定义的文件描述符4上

shs="sh_1 sh_2 sh_3"
for i in $shs;
do
read -u4 #从管道中读取行，每次一行，所有行读取完毕后执行挂起，直到管道有空闲的行
{
#p1 p2 p3是脚本需要的参数 > 后面表示将$i.sh的日志重定向到${i}.log这个文件中
sh ${sh_directory}/$i.sh $p1 $p2 $p3 > "${sh_directory}/${i}.log" 2>&1
echo "" >&4 #再写入一个空行，使挂起的循环继续执行
}& #放入后台执行
done
#等待所有线程执行完毕
wait
exec 4>&- #删除文件描述符

print_log "并发执行结束" 

#将并发产生的日志写入datahub日志文件中
declare -a results;
flag=0
for i in $shs;
do
#打印日志，会自动将日志写入datahub日志文件中
print_log "--------------------------------------"
print_log "${i}执行日志如下："
cat ${sh_directory}/${i}.log
#获取日志最后一行,判断执行是否成功
result=`tail -n 1 ${sh_directory}/${i}.log`
if [[ "$result" = "#success#" ]];then
results[$flag]="true"
print_log "${i}执行结果success"
else
results[$flag]="false"
print_log "${i}执行结果failed"
fi
((flag++))
#删除并发产生的日志文件
rm ${sh_directory}/${i}.log
done

#判断是否所有脚本都执行成功,如果有一个执行失败,则退出程序
for i in ${results[@]}
do
if [[ ${i} == "false" ]];then
print_log "有并发脚本运行失败,请查看脚本是否正确"
exitCodeCheck 1 $startsec $run_serial_no $task_name
fi
done


#代码段 2 结束
exitCodeCheck $? $startsec $run_serial_no $task_name


#===============脚本任务结束===============
endsec=$(date +%s)
message="脚本耗时: $[ endsec-startsec ] 秒"
echo $message

# 回传状态给datahub
callDatahub 0 "$message" "$run_serial_no" "$task_name"
